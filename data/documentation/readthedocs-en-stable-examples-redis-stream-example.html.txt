Redis Stream Examples# basic config# add some data to the stream# if we call the xread with the same arguments we will get the same data to get new data we need to change the key passed to the call to get only newer entries to get the last entry in the stream Add some messages to a 2nd stream get messages from the 2 streams  redis_host="redis"stream_key="skey"stream2_key="s2key"group1="grp1"group2="grp2"  importredisfromtimeimporttimefromredis.exceptionsimportConnectionError,DataError,NoScriptError,RedisError,ResponseErrorr=redis.Redis(redis_host)r.ping()    foriinrange(0,10):r.xadd(stream_key,{'ts':time(),'v':i})print(f"stream length: {r.xlen( stream_key )}")   ## read 2 entries from stream_keyl=r.xread(count=2,streams={stream_key:0})print(l)   first_stream=l[0]print(f"got data from stream: {first_stream[0]}")fs_data=first_stream[1]forid,valueinfs_data:print(f"id: {id} value: {value[b'v']}")   l=r.xread(count=2,streams={stream_key:0})forid,valueinl[0][1]:print(f"id: {id} value: {value[b'v']}")   last_id_returned=l[0][1][-1][0]l=r.xread(count=2,streams={stream_key:last_id_returned})forid,valueinl[0][1]:print(f"id: {id} value: {value[b'v']}")   last_id_returned=l[0][1][-1][0]l=r.xread(count=2,streams={stream_key:last_id_returned})forid,valueinl[0][1]:print(f"id: {id} value: {value[b'v']}")   print(f"stream length: {r.xlen( stream_key )}")# wait for 5s for new messagesl=r.xread(count=1,block=5000,streams={stream_key:'$'})print(f"after 5s block, got an empty list {l}, no *new* messages on the stream")print(f"stream length: {r.xlen( stream_key )}")   # read the last available messagel=r.xread(count=1,streams={stream_key:'+'})print(l)print(f"stream length: {r.xlen( stream_key )}")   foriinrange(1000,1010):r.xadd(stream2_key,{'v':i})print(f"stream length: {r.xlen( stream2_key )}")   l=r.xread(count=1,streams={stream_key:0,stream2_key:0})fork,dinl:print(f"got from {k} the entry {d}")   basic config#  redis_host="redis"stream_key="skey"stream2_key="s2key"group1="grp1"group2="grp2"  connection#  importredisfromtimeimporttimefromredis.exceptionsimportConnectionError,DataError,NoScriptError,RedisError,ResponseErrorr=redis.Redis(redis_host)r.ping()    xadd and xread# add some data to the stream# if we call the xread with the same arguments we will get the same data to get new data we need to change the key passed to the call to get only newer entries to get the last entry in the stream Add some messages to a 2nd stream get messages from the 2 streams  foriinrange(0,10):r.xadd(stream_key,{'ts':time(),'v':i})print(f"stream length: {r.xlen( stream_key )}")   ## read 2 entries from stream_keyl=r.xread(count=2,streams={stream_key:0})print(l)   first_stream=l[0]print(f"got data from stream: {first_stream[0]}")fs_data=first_stream[1]forid,valueinfs_data:print(f"id: {id} value: {value[b'v']}")   l=r.xread(count=2,streams={stream_key:0})forid,valueinl[0][1]:print(f"id: {id} value: {value[b'v']}")   last_id_returned=l[0][1][-1][0]l=r.xread(count=2,streams={stream_key:last_id_returned})forid,valueinl[0][1]:print(f"id: {id} value: {value[b'v']}")   last_id_returned=l[0][1][-1][0]l=r.xread(count=2,streams={stream_key:last_id_returned})forid,valueinl[0][1]:print(f"id: {id} value: {value[b'v']}")   print(f"stream length: {r.xlen( stream_key )}")# wait for 5s for new messagesl=r.xread(count=1,block=5000,streams={stream_key:'$'})print(f"after 5s block, got an empty list {l}, no *new* messages on the stream")print(f"stream length: {r.xlen( stream_key )}")   # read the last available messagel=r.xread(count=1,streams={stream_key:'+'})print(l)print(f"stream length: {r.xlen( stream_key )}")   foriinrange(1000,1010):r.xadd(stream2_key,{'v':i})print(f"stream length: {r.xlen( stream2_key )}")   l=r.xread(count=1,streams={stream_key:0,stream2_key:0})fork,dinl:print(f"got from {k} the entry {d}")   add some data to the stream#  foriinrange(0,10):r.xadd(stream_key,{'ts':time(),'v':i})print(f"stream length: {r.xlen( stream_key )}")   read some data from the stream#  ## read 2 entries from stream_keyl=r.xread(count=2,streams={stream_key:0})print(l)   extract data from the returned structure#  first_stream=l[0]print(f"got data from stream: {first_stream[0]}")fs_data=first_stream[1]forid,valueinfs_data:print(f"id: {id} value: {value[b'v']}")   read more data from the stream# if we call the xread with the same arguments we will get the same data to get new data we need to change the key passed to the call to get only newer entries to get the last entry in the stream  l=r.xread(count=2,streams={stream_key:0})forid,valueinl[0][1]:print(f"id: {id} value: {value[b'v']}")   last_id_returned=l[0][1][-1][0]l=r.xread(count=2,streams={stream_key:last_id_returned})forid,valueinl[0][1]:print(f"id: {id} value: {value[b'v']}")   last_id_returned=l[0][1][-1][0]l=r.xread(count=2,streams={stream_key:last_id_returned})forid,valueinl[0][1]:print(f"id: {id} value: {value[b'v']}")   print(f"stream length: {r.xlen( stream_key )}")# wait for 5s for new messagesl=r.xread(count=1,block=5000,streams={stream_key:'$'})print(f"after 5s block, got an empty list {l}, no *new* messages on the stream")print(f"stream length: {r.xlen( stream_key )}")   # read the last available messagel=r.xread(count=1,streams={stream_key:'+'})print(l)print(f"stream length: {r.xlen( stream_key )}")   2nd stream# Add some messages to a 2nd stream get messages from the 2 streams  foriinrange(1000,1010):r.xadd(stream2_key,{'v':i})print(f"stream length: {r.xlen( stream2_key )}")   l=r.xread(count=1,streams={stream_key:0,stream2_key:0})fork,dinl:print(f"got from {k} the entry {d}")   use a group to read from the stream# With the groups is possible track, for many consumers, and at the Redis side, which message have been already consumed. ## add some data to streams Creating 2 streams with 10 messages each. create a group grp1 with the stream skey, and create a group grp2 with the streams skey and s2key Use the xinfo_group to verify the result of the group creation. The xreadgroup method permit to read from a stream group. A 2nd consumer for the same stream group will get not delivered messages. But a 2nd stream group can read the already delivered messages again. Note that the 2nd stream group include also the 2nd stream. That can be identified in the reply (1st element of the reply list). To check for pending messages (delivered messages without acknowledgment) we can use the xpending. Acknowledge some messages with xack. ack all messages on the group1. But stream length will be the same after the xack of all messages on the group1. To remove the messages with need to remove them explicitly with xdel. stream length But with the xdel the 2nd group can read any not processed message from the skey.  defadd_some_data_to_stream(sname,key_range):foriinkey_range:r.xadd(sname,{'ts':time(),'v':i})print(f"stream '{sname}' length: {r.xlen( stream_key )}")add_some_data_to_stream(stream_key,range(0,10))add_some_data_to_stream(stream2_key,range(1000,1010))   ## create the groupdefcreate_group(skey,gname):try:r.xgroup_create(name=skey,groupname=gname,id=0)exceptResponseErrorase:print(f"raised: {e}")# group1 read the stream 'skey'create_group(stream_key,group1)# group2 read the streams 'skey' and 's2key'create_group(stream_key,group2)create_group(stream2_key,group2)defgroup_info(skey):res=r.xinfo_groups(name=skey)foriinres:print(f"{skey} -> group name: {i['name']} with {i['consumers']} consumers and {i['last-delivered-id']}"+f" as last read id")group_info(stream_key)group_info(stream2_key)   defprint_xreadgroup_reply(reply,group=None,run=None):ford_streaminreply:forelementind_stream[1]:print(f"got element {element[0]}"+f"from stream {d_stream[0]}")ifrunisnotNone:run(d_stream[0],group,element[0])  # read some messages on group1 with consumer 'c'd=r.xreadgroup(groupname=group1,consumername='c',block=10,count=2,streams={stream_key:'>'})print_xreadgroup_reply(d)   # read some messages on group1 with consumer 'c'd=r.xreadgroup(groupname=group1,consumername='c2',block=10,count=2,streams={stream_key:'>'})print_xreadgroup_reply(d)   d2=r.xreadgroup(groupname=group2,consumername='c',block=10,count=2,streams={stream_key:'>',stream2_key:'>'})print_xreadgroup_reply(d2)   # check pending status (read messages without a ack)defprint_pending_info(key_group):fors,kinkey_group:pr=r.xpending(name=s,groupname=k)print(f"{pr.get('pending')} pending messages on '{s}' for group '{k}'")print_pending_info(((stream_key,group1),(stream_key,group2),(stream2_key,group2)))   # do acknowledges for group1toack=lambdak,g,e:r.xack(k,g,e)print_xreadgroup_reply(d,group=group1,run=toack)   # check pending againprint_pending_info(((stream_key,group1),(stream_key,group2),(stream2_key,group2)))   d=r.xreadgroup(groupname=group1,consumername='c',block=10,count=100,streams={stream_key:'>'})print_xreadgroup_reply(d,group=group1,run=toack)print_pending_info(((stream_key,group1),))   r.xlen(stream_key)    s1=r.xread(streams={stream_key:0})forstreamsins1:stream_name,messages=streams# del all ids from the message list[r.xdel(stream_name,i[0])foriinmessages]  r.xlen(stream_key)    d2=r.xreadgroup(groupname=group2,consumername='c',block=10,count=2,streams={stream_key:'>',stream2_key:'>'})print_xreadgroup_reply(d2)     use a group to read from the stream# create a group grp1 with the stream skey, and create a group grp2 with the streams skey and s2key Use the xinfo_group to verify the result of the group creation.  ## create the groupdefcreate_group(skey,gname):try:r.xgroup_create(name=skey,groupname=gname,id=0)exceptResponseErrorase:print(f"raised: {e}")# group1 read the stream 'skey'create_group(stream_key,group1)# group2 read the streams 'skey' and 's2key'create_group(stream_key,group2)create_group(stream2_key,group2)defgroup_info(skey):res=r.xinfo_groups(name=skey)foriinres:print(f"{skey} -> group name: {i['name']} with {i['consumers']} consumers and {i['last-delivered-id']}"+f" as last read id")group_info(stream_key)group_info(stream2_key)   group read# The xreadgroup method permit to read from a stream group. A 2nd consumer for the same stream group will get not delivered messages. But a 2nd stream group can read the already delivered messages again. Note that the 2nd stream group include also the 2nd stream. That can be identified in the reply (1st element of the reply list). To check for pending messages (delivered messages without acknowledgment) we can use the xpending.  defprint_xreadgroup_reply(reply,group=None,run=None):ford_streaminreply:forelementind_stream[1]:print(f"got element {element[0]}"+f"from stream {d_stream[0]}")ifrunisnotNone:run(d_stream[0],group,element[0])  # read some messages on group1 with consumer 'c'd=r.xreadgroup(groupname=group1,consumername='c',block=10,count=2,streams={stream_key:'>'})print_xreadgroup_reply(d)   # read some messages on group1 with consumer 'c'd=r.xreadgroup(groupname=group1,consumername='c2',block=10,count=2,streams={stream_key:'>'})print_xreadgroup_reply(d)   d2=r.xreadgroup(groupname=group2,consumername='c',block=10,count=2,streams={stream_key:'>',stream2_key:'>'})print_xreadgroup_reply(d2)   # check pending status (read messages without a ack)defprint_pending_info(key_group):fors,kinkey_group:pr=r.xpending(name=s,groupname=k)print(f"{pr.get('pending')} pending messages on '{s}' for group '{k}'")print_pending_info(((stream_key,group1),(stream_key,group2),(stream2_key,group2)))   ack# Acknowledge some messages with xack. ack all messages on the group1. But stream length will be the same after the xack of all messages on the group1.  # do acknowledges for group1toack=lambdak,g,e:r.xack(k,g,e)print_xreadgroup_reply(d,group=group1,run=toack)   # check pending againprint_pending_info(((stream_key,group1),(stream_key,group2),(stream2_key,group2)))   d=r.xreadgroup(groupname=group1,consumername='c',block=10,count=100,streams={stream_key:'>'})print_xreadgroup_reply(d,group=group1,run=toack)print_pending_info(((stream_key,group1),))   r.xlen(stream_key)    delete all# To remove the messages with need to remove them explicitly with xdel. stream length But with the xdel the 2nd group can read any not processed message from the skey.  s1=r.xread(streams={stream_key:0})forstreamsins1:stream_name,messages=streams# del all ids from the message list[r.xdel(stream_name,i[0])foriinmessages]  r.xlen(stream_key)    d2=r.xreadgroup(groupname=group2,consumername='c',block=10,count=2,streams={stream_key:'>',stream2_key:'>'})print_xreadgroup_reply(d2)     